<html>
<head>
  <title>Know Your Ruby</title>

  <LINK REL="SHORTCUT ICON" HREF="img/ruby.gif"/>
  <LINK REL=StyleSheet HREF="style.css" TITLE="Times" TYPE="text/css">

  <style>
    div#formats { 
      margin-top: -190px; margin-right: 200px; text-align: right;
      color: green; font-size: 8pt;
    }
  </style>
</head>

<body>

<div id="text" style="padding-top: 50px;">

<!--
  <div id="copy" style="text-align: center;">
    Copyright &copy; 2006 Thomas Sawyer.<br/> All rights reserved.
  </div>
-->

<!--
<div id="header">
  <br/>
  <span id="title">Roll</span></br>
  <span id="subtitle">&nbsp;Ruby object-oriented library ledger</span></br>
</div>
-->

<div id="toc">

  <img src="img/red_book.gif" align="left" style="margin-top: -60px; padding: 10px;"/>

  <div id="title1">Library Class</div>

  <div id="title2">&nbsp;Library Management and Remote Loading</div>

  <br/>

</div>

<br/><br/>

<h1 style="margin-top: 0px;">Table of Contents</h1>

<ol type="1">
  <li> <a href="#ch1"> Understanding Library Management       </a></li>
  <li> <a href="#ch2"> Putting a Library to Use               </a> </li>
  <li> <a href="#ch2"> Examining a Library's Metadata         </a> </li>
  <li> <a href="#ch3"> Versioning your Library for Deployment </a> </li>
  <li> <a href="#ch2"> Securely Requiring by Remote           </a> </li>
  <li> <a href="#ch4"> Benefits of using Library Class        </a> </li>
</ol>


<p><i>Special thanks to Peter Vanbroekhoven for his work on this library.</i></p>

<!-- INTRO -->

<h1 id="ch1"> Understanding Library Management </h1>

<p>Ratchet's provides a Libary class which is a light-weight,
object-oriented library register system for Ruby.
In other words, a library, which is essentially a location in Ruby's 
site load path, can be instantiated as an object. Then used to provide useful
meta-information about library, in addition to providing the usual
#require and #load methods against the files belonging to the library.</p>

<!--
<p>The system consists of a script, <span class="red">roll.rb</span>,
two sumplemental scripts, library.rb and version_number.rb, along with a
couple of simple conventions for taking advantage of it's benefits.
The code base totals well under 1,000 Lines of code, making it clear,
concise and robust.</b>
-->


  <table style="margin-left: 30px;">
  <tr><td> &middot; Object-oriented library interface </td></tr>
  <tr><td> &middot; Promotion of standard conventions </td></tr>
  <tr><td> &middot; Flexible support for versioning </td></tr>
  <tr><td> &middot; Helps ensure against file name clashes </td></tr>
  <tr><td> &middot; Library organization independent of load path </td></tr>
  <!--
  <li>Safely allows relative, instead of absolute, requiring</li>
  <li>Supports "private" library sub-directories</li>
   -->
  <tr><td> &middot; Works seamlessly within the standard site_ruby layout </td></tr>
  <tr><td> &middot; Is not tied to a particular package/distribution system </td></tr>
  </table>



<!-- USING -->

<h1 id="ch_user"> Putting a Library to Use </h1>

<p>Most likely the first thing you'll wnat to do before utilizing Ratchet's library managemnt system is
add <code>-roll</code> to your <code>RUBYOPT</code> environment variable.</p>

  <pre>
    $ export RUBYOPT="-rubylib"
  </pre>

<p>You may want to add this to the master profile or to your own
.bashrc file so it starts automatically in the future.</p>

<p>Using a rolled Ruby library isn't much different than using a non-rolled
one. For instance the demo app incuded in the Rolls distribution can
be tested (after installing it) from irb just by typing:</p>

  <pre>
    require 'fruitapp/tryme'
  </pre>

<p>The roll system will detect that 'fruitapp' is a "rolled" library and automatically
instantiate it, selecting the most recent version, then proceed to require <code>tryme.rb</code>.</p>

<!--
<p>In the above example Rolls has to figure out that <code>fruitapp</code> is a rolled library.
While marginal, the efficiency can be increased by explicitly telling Rolls that <code>mylib</code>
is a rolled library. This is done by simply dividing the library portion of the path from
the file portion with a colon ':' instead of a slash.</p>

<pre>
    require 'mylib:tryme'
</pre>

<p>This has the added advantage of providing a visual indication of a rolled lib.</p>
-->

<p>Rather then have Rolls automatically select the latest verison you can manually <i>activate</i>
a specific version via a version constraint. This is most easily achieved with the provided
<code>#library</code> Kernel method.</p>

  <pre>
    library 'fruitapp', '= 1.0'
    require 'fruitapp/tryme'
  </pre>

<p>So in this example, specifically version 1.0 of fruitapp will be used.
The <code>#library</code> method does more than simply select a version.
In fact, the verison parameter is optional --when no version constraint is given
the most recent available version is selected. The <code>#library</code> method 
also returns returns a <i>Library</i> object.</p>

<p>Ah, but now we're starting to go beyond the "Quick" of things.
That's pretty much all you <i>have</i> to know to use a "rolled" library.</p>


<h2 id="ch_class"> The Library Class </h2>

<p>When you use the Kernel method, <code>#library</code>, you're actually just using a shortcut for
instantiating a new Library object. You can do the same thing using <code>Library.instance</code>
or <code>Library.open</code> methods.</p>

  <pre>
    Library.instance('fruitapp')   #=> #&lt;Library fruitapp/1.0.1&gt;
    Library.open('fruitapp')       #=> #&lt;Library fruitapp/1.0.1&gt;
  </pre>

<p>The <code>#instance</code> and <code>#open</code> methods require the library name as the
first parameter, which is also the name of the library's directory within the site_ruby system
location(s). The name is then used as the ledger key to track the library.
The difference between <code>#instance</code> and <code>#open</code> is that <code>#open</code>
will raise an error if the library is not found and can also take a block which yields on the
library. In addition, there is a shorter alias for <code>#instance</code> provided as
<code>#[]</code>. Like <code>#instance</code>, it too will not raise an error if the
the library is not found, but will simply return nil.</p>

  <pre>
    Library['fruitapp']  #=> #&lt;Library fruitapp/1.0.1&gt;
    Library['notthere']  #=> nil
  </pre>

<p>Library is <i>multiton</i>, which means only one instance exists per name. 
Calling <code>#library</code>, <code>#instance</code>, <code>#open</code> or 
<code>#[]</code> repeatedly using the same name will return the very same
Library object each time.</p>

<p>When selecting a version, the constraint is a simple string starting with an
operator, like <code>=</code> or <code>&gt;=</code>, followed by the string 
representaion of a version number. For instance,</p>

  <pre>
    Library.instance('fruitapp', '~> 1.0')     #=> #&lt;Library fruitapp/0.9&gt;
    Library.instance('fruitapp', '== 2.0')     #=> #&lt;Library fruitapp/2.0&gt;
  </pre>

<p>Once a version is selected the version can not be changed.
A Library::VersionConflict will be raised if one attempts to do so.</p>

<p><i>NOTE: This restriction has put in place to prevent conflicts which
can arise when libraries extend core functionality. Certainly it would be
nice if multiple-versions could work harmoniously, but this not even 
remotely possible until such time as Ruby supports selector namespaces.
In the future though we may be able to reduce the restrinction to just
the use of #require and #load.</i></p>

<!-- However, Roll will not raise and error should
you have special need to do exactly that (although it may raise a warning).
Once selected, the Library class will delegate calls to the current
version. If you attempt to use a library without first selecting a
version, the latest version will be atomically selected.-->

<p>Now, with a library in hand, the most useful method provided is #require.</p>

  <pre>
    library('fruitapp').require 'tryme'
  </pre>

<p>As you can see this is pure OOP. You could store the reference to
the library for later access, even pass it around as an argument.</p>

  <pre>
    fruitlib = Library.open('fruitapp', '=1.0')
    fruitlib.require 'tryme'
  </pre>


<h2 id="ch_other"> Related Locations </h2>

<p>To facilitate access to file locations pertaining to
a library, Rolls provides some convenient methods.
Normally this information is accessed by using rbconfig.rb and
building a path based on information in the Config::CONFIG hash.
For instance, <code>Config:CONFIG['datadir']</code>
on a Debian system points to /usr/share. With Roll you can look up
the data dir specific to the current library via the <code>#datadir</code> 
method, and likewise for the other directories. Here's a example rundown
with resolutions for a Debian system.</p>

<!--
<pre>
  # library directory
  library('fruitapp').libdir           #=> [ "/usr/local/lib/site_ruby/1.8/fruitapp/1.0.0/" ]
-->

  <pre>
    # configuration dir
    library('fruitapp').confdir          #=> "/etc/fruitapp/"

    # versioned data dir
    library('fruitapp').datadir          #=> "/usr/share/fruitapp/1.0.0/"

    # ensure non-versioned data dir
    library('fruitapp').datadir(true)    #=> "/usr/share/fruitapp/"
  </pre>

<p>Another way to access these locations is via Ruby's own Config module. Eg.
Config.datadir('fruitapp'). This provides a wholly general interface
to this information, irregardless of the system providing it, whether it be
Rolls, Gems or some other system.</p>

<p>With Rolls, a project's <code>bin/</code> directory is not versioned, unlike
the <code>lib/</code> directory. It doesn need to be because a simple
convention makes it possible to version executable files: In so far as an executable
is to be versioned (and it's generally a good idea to do so) one should put the logic
in a file under the versioned <code>lib/</code> directry, then simply requiring or
load the lib file into the executable file. It's a simple enough practice and doing
it in this manner means that no specialized action is required of any packaging
or distribution system. Here is a good example of such a file.</p>

  <pre>
    #!/usr/bin/env ruby
    require 'roll.rb'
    version = "> 0"
    if ARGV.size > 0 && ARGV[0][0]==95 && ARGV[0][-1]==95
      if Library::Version.correct?(ARGV[0][1..-2])
        version = ARGV[0][1..-2]
        ARGV.shift
      end
    end
    library 'camping', version
    load 'camping'
  </pre>

<h2 id="ch_meta"> Library Metadata </h2>

<p>Additional meta-information may also be provided via a library's
specification file which is accessible via the <code>Library</code>
interface. This is optional information that may or may not be
provided by the project developers.</p>

<p>To tell if any meta-information has been provided, query the 
library with the <code>#metainfo?</code> call. If so then other
information can be queried. For instance:</p>

  <pre>
    library('fruitapp').title        #=> "Fruit Basket Application"
    library('fruitapp').description  #=> "Example application to demonstrate roll.rb."
    library('fruitapp').author       #=> "Trans"
  </pre>

<p>Additional fields will be added in the future as prove suitable.</p>



<!-- DEVELOPING -->

<h1 id="ch_dev"> Rolling for Developers </h1>

<h2 id="ch_layout"> Versioned Layout </h2>

<p>Roll supports library versioning through a straight-forward no-nonsense
directory structure. By simply laying out a project's <code>lib/</code>
directory with an additional version tier, there is no need for special
installation repositories, procedures or supporting programs. A tar file
and trusty setup.rb are all that one needs.</p>

<p>Your directory layout should follow the general conventions set
by Minero Aoki's <code>setup.rb</code>. Roll simply adds a couple
additional details. Here's an example of an well structured versioned
project directory layout.</p>

<!--
<p>To support versioning and to encourage clean divisions between projects,
Roll has taken a <i>inspiration</i> from the <b>taguri</b>
standard as a basis for library file and directory names.
You can learn more about taguri <a href="http://taguri.org">here</a>.<p>
The taguri standard is not suitable in itself to designate file and
directory names, but with some basic transformations and additions it is
admirably useful. Here is an example of what a projects taguri would be and
how that translates into a directory structure and a tar package file name.</p>

<pre>
  (1) tag:fruitbasket.rubyforge.org,2005-10-31:tryme.rb
  (2) fruitbasket.rubyforge.org/2005-10-31/tryme.rb
  (3) fruitbasket.rubyforge.org-2005.10.31.tgz (contains tryme.rb)
</pre>

<p>The first is the standard taguri. The second is how it is
represented in file system. And the third is, of course,
the directory packed in a tar file. While we would have liked the
packaged file name to more closely resemble the original taguri,
many source host services do not allow file names to have commas.
But also notice how the the date becomes a sub-directory of the uri.
This represents the version, and as such it need not be a date
--it could just as well be a series like '1.0.0'.</p>

<p>For clarity here's the above as it translates into a project's directory
layout.</p>
-->

  <pre>
    fruitapp/
      bin/
        ...
      lib/
        fruitapp/
          1.0.0/
            index.rb
            ...
  </pre>

<p>It's important to understand that while Rolls needs the versioned
directory layout <i>post installation</i>, it does not need to have
this structure for development. Using a tool, such as Reap or your
own Rake script, to move the files into the appropraite place in a
distributable package prior to distribution will work just as well.</p>

<p>At this point you may be wondering how renaming the lib directory with a
changing version is even possible --how will the internal require statements
find their files? It's actually quite simple. When Rolls is required the
first thing it does is search the standard site locations and makes
a map of of available libraries and their versions. Then when a library is
first referenced it is instatiated with a particluar version. From then on
requests against that libary are routed to that library object where the
correct path is used.</p>

<p>Rolls also works without version subtiers and the two can even be mixed.
If two files with the same name exist in the versioned tier and the
non-versioed tier, the versioned file will take precedence.</p>

<!--
<h2 id="ch_local"> A Note or Two on Version Numbers </h2>

<p>Though the taguri standard suggests using a dating scheme to
differentiate library versions in the directory hierarchy, Roll
fully supports both date and dot-series versioning. How to utilize either
of these is a matter to be decided by the project's maintainer.
But we'll touch on them briefly to help understand the two useful methods.</p>

<p>Series-versioning is the most common form versioning in use today. If you take
a close look at the versions put out by a plethora of projects you will also
notice that it is more akin to an art-form than a science[<a href="#foot1">1</a>].
Nonetheless, if you follow a strict Rational Versioning Policy
of "major.minor.tiny" with regards to project changes, it can be helpful
in conveying <i>compatibility</i>, which can in turn provide the end-user
some means of insurance that their programs will remain functional even
after updates.</p>

<p>Date-versioning, OTOH, is not as common mainly because it is not
typically thought to have any semantic value beyond a release timestamp.
But by creatively utilizing the taguri standard, date-versioning can in
fact lend itself to greater version consistency with regard to release
<i>stability</i>. Just follow these four simple rules:
<pre>
  1) Unstable/development releases provide the day (YYYY-MM-DD)
  2) Official/stable releases remove the day (YYYY-MM)
  3) Ultrastable releases provide only the year (YYYY)
  4) For daily builds add a "build moment" by adding the time.
</pre>
With this Rational Versioning Policy, the intent is clear and meaningful and
has a natural way of forcing one to comply to the meaning, which is nice.
</p>
-->


<h2 id="ch_index"> The <code>index.rb</code> File </h2>

<p><i>NOTE: The autoloading of the index.rb file is currently remarked out of
code as I evaluate it's true utility.</i></p>

<p>You may be wondering what the </code>index.rb</code> file given in
the last exmaple. When a library is instantiated Rolls looks to see if
there is an index.rb file accosiated with it. If there is, it requires it.
index.rb is an optional file that can be used to automatically provide 
meta-information particular to the library and it's version, or to
automatically perform any setup that may be required upon instantiation
of the library.</p>

<p>The typical <code>index.rb</code> file will provided meta-information
about the library. The simplist way to provide this is via the
#index method.</p>

  <pre>
    library('fruitapp').index do
      date  '2005-10-10'
      title 'Fruit Demo Applicaiton for Rolls'
    end
  </pre>

<p>This is the same as the less convenient form.</p>

  <pre>
    require 'roll/library.rb'
    library('fruitapp').date  '2005-10-10'
    library('fruitapp').title 'Fruit Demo Applicaiton for Rolls'
  </pre>

<p>Or using <code>#open</code>.</p>

  <pre>
    require 'roll/library.rb'
    library('fruitapp').open do |lib|
      lib.date  '2005-10-10'
      lib.title 'Fruit Demo Applicaiton for Rolls'
    end
  </pre>

<p>The index file is loaded via #require just like any other file, so you can
run whatever code neccessary for the initialization of a library. In this
sense, the index.rb file is a library's version of a callback method.</p>


<h2 id="ch_scope"> Load Scope </h2>

<p>One of the more useful settings one might use the index.rb to set is
the internal load scope of a library. By default the load path of a library
is it's main directory, according to the library's name. But you can diversify
the load paths if you wish via the <code>#scope</code> call.

<p>Let us consider an example. Assume the following <code>lib/</code> layout:</p>

  <pre>
    fruitapp/
      1.0.0/
        fruit/
          apple.rb
        basket/
          wicker.rb
  </pre>

<p>By providing the library with a scope detailing which sub-directories
are to be accessible via the directory name, the internal directories are
automatically exposed to one another. 

  <pre>
    library('fruitapp').scope( '.', 'fruit', 'basket' )
  </pre>

<p>So given the above, when requiring against the library, the system will search
all three internal paths instead of just the main ('.') path. The file 
<code>apple.rb</code> can contain <code>require 'fruitapp/wicker.rb'</code> 
and it will find the file in the <code>basket/</code> directory.</p>

<!--
<p>As mentioned in the features, Rolls provides internal library files access to
the library files around them without specifying absolute path names (i.e. relative
to the standard $LOAD_PATH). This is useful because it allows one the freedom
to reversion directories or rename subdirectories without needing to update every
require reference in one's scripts.</p>
-->


<!--
<p>is also made true by this. But lets say you do not wish for the
internal visibility to be the same as the outside visibility. Then
in addition to <code>main</code> provide a <code>scope</code> parameter.</p>

<pre>
  private:
    - foo
    - bar
</pre>

<p>In this example, internal files in the foo/ and bar/ directories will
be able to see each other, but they will not be able to see the library's
root directory (unless they specify the library's specific namespace, of course).
One can invert the coverage of the scope, having main contain less directories
and scope containing more. In this way the roll system provides semi-private
library directories.</p>

<p>Albeit rare, you should keep in mind that a conflict can arise if your
library contains a file within it's local scope that has the same name as
an external library or a built-in Ruby standard library file.
This will only effect a library trying to access both files.
When this occurs the local library file will take precedence. There are
two way to circumvent this. Firstly, you can specifically specify the 
library if it is another rolled library.</p>

<pre>
  library('alib').require 'afile.rb'
</pre>

Or you can use the specialized '::' marker to access standard ruby.</p>

<pre>
  require '::ostruct.rb'
</pre>

<span class="note">(NOTE <i>Presently <code>Library['ruby']</code> is NOT viable, but
it will be supported in the future.</i>)</span>
-->


<h2 id="ch_run"> Live Development </h2>

<p>Another nice feature of Rolls is the ability run an entire project completely
from the current working directory. If the $DEBUG flag is set (eg. ruby -d),
Rolls will ascend from current working directory searching for the a
<code>lib/</code> folder. If found the location is added to the $LOAD_SITES
list (like $LOAD_PATH but specific to Rolls). So it is easy to test
code directly from the development location, without any need to install.</p>


<!-- CHOOSING -->

<h1 id="ch_choose"> Benefits </h1>

<p>Because Rolls in package system agnostic, it is advantageous to the package maintainers
of operating systems. It is straight forward to repackage you libraries in their
favored packaging system.</p>

<p> This overview of Rolls makes no mention of the library it will inevitably compete against.
If you hadn't already realized, that library is the beloved Gems. No doubt Gems is great tool
and a lot of great work has been put into it. Rolls will work right along side Gems with out
complaint. Nonetheless Gems has some shortcomings which were the very motivation for the
creation of Rolls. Namely, that Gems is over reaching. Specifically, the fact that Gems
combines a package management system and a versioning system into an inseparable unit presents
unwarranted limitations. It would be understandable if there was no alternative, but
as Rolls demonstrates there is a very viable recourse.</p>

<p>So, Are you Ready to Roll?</p>

<p>Do you want the advantages of Rolls? Given that Roll is light-weight,
robust and will work alongside Gems, thus allowing smooth transition,
adding a dependency to RubyRoll is a relatively easy choice.</p>

<p>To get started all you need is a way to repackage you project into
a roll compatible layout. We created this spiffy graphic you can use to 
let other know you offer a rolls compatible distribution.</p>

<br/><br/>

<p>&nbsp;&nbsp;<img src="img/ready.png"/></p>

<p> ... </p>

</div>


<hr>

<div id="footnotes">
Footnotes:<br/>
[1] <a href="http://www.newsforge.com/article.pl?sid=05/06/08/136214&from=rss">Decline and fall of the version number</a>
</div>

<div id="copy">Copyright (c) 2005 Thomas Sawyer, all rights reserved.</div>

</html>
