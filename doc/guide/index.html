<html>
<head>
  <title>Ready to Roll</title>
  <LINK REL="SHORTCUT ICON" HREF="img/ball/red_ball.jpg"/>
  <style>
             body { font-family: sans-serif; margin: 20px; color: #222222;
                    font-size: 11pt;}
               hr { margin: 0 auto; width: 710px; }
               li { font-size: 1em; }
                p { font-size: 1em; line-height: 1.2em; }
               h1 { margin-top: 50px; }
               h2 { margin-top: 40px; }
             code { color: red; font-size: 0.9em; }
              pre { color: red; font-size: 0.9em; }
        div#title { margin: 0 auto; width: 700px; text-align: left; margin-bottom: 30px; }
    div#container { margin: 0 auto; width: 700px; text-align: justify; margin-bottom: 30px; }
       span#title { color: red; font-family: monospace; font-size: 96px;
                    letter-spacing: 10pt; font-weight: bold; }
    span#subtitle { color: black; font-size: 10pt; padding-left: 0px; font-weight: bold; }
         span#rev { background: red; color: white; }
    div#footnotes { margin: 0 auto; width: 700px; font-size: 0.8em; }
         div#copy { margin: 0 auto; width: 700px; font-size: 0.8em; margin-top: 30px; }
         span.red { color: red; }
       span.small { font-size: 10pt; }
       span.note  { font-size: 1em; font-style: italic; }
  </style>
</head>
<body>

<div id="title">
  <div style="float:right;"><img src="img/ball/red_ball.jpg" height="200px"></div>
  <br/>
  <span id="title">Roll</span></br>
  <span id="subtitle">&nbsp;ruby's object-oriented library ledger</span></br>
</div>

<div id="container">

<br/><br/>

<div style="border: 2px solid red; padding: 10px;">
  <b>IMPORTANT NOTICE</b><br/><br/>
  THIS IS STILL VERY MUCH A WORK IN PROGRESS. IT IS FAR FROM COMPLETE AND DOES NOT NECESSARILY MATCH WITH THE CURRENT STATE OF DEVELOPMENT!!!
</div>

<h1> Table of Contents </h1>

  <ol>
   <li> <a href="#ch_info">Introduction</a>
    <ol>
      <li><a href="#ch_about">   What is Roll(s)? </a></li>
      <li><a href="#ch_feature"> Feature Highlights        </a></li>
      <li><a href="#ch_install"> How to Install            </a></li>
      <li><a href="#ch_who">     Who Developed This?       </a></li>

    </ol>
   </li>
   <li> <a href="#ch_user">Rolling for End Users</a>
    <ol>
      <li><a href="#ch_quick">   Quick Rollout             </a></li>
      <li><a href="#ch_class">   The Library Class         </a></li>
      <li><a href="#ch_other">   Related Locations         </a></li>
      <li><a href="#ch_meta">    Library Metadata          </a></li>
    </ol>
   </li>
   <li> <a href="#ch_dev">Rolling for Developers</a>
    <ol>
      <!-- <li><a href="#ch_libver">   Library Versioning     </a></li> -->
      <li><a href="#ch_layout">  Versioned Layout          </a></li>
      <li><a href="#ch_roll">    The .roll File            </a></li>
      <li><a href="#ch_scope">   Load Scope                </a></li>
      <li><a href="#ch_index">   The index.rb File         </a></li>
      <li><a href="#ch_run">     Live Development          </a></li>
    </ol>
   </li>
   <li> <a href="#ch_choose">It's How We Roll</a>
    <ol>
      <li><a href="#ch_maint">   Benefits to Package Maintainers  </a></li>
      <!-- <li><a href="#ch_gems">    Rolling past Gems                </a></li> -->
      <li><a href="#ch_concl">   Are You Ready to Roll?           </a></li>
    </ol>
   </li>
  </ol>

<br/>

<h1 id="ch_info"> Introduction </h1>

<h2 id="ch_about"> What is Roll(s)? </h2>

<p><span class="red">Roll</span> (or <span class="red">Rolls</span>)
is a flexible light-weight object-oriented library ledger
system for the Ruby programming language. In other words, a library,
which is essentially a location in a file system, can be instantiated
as an object, then used to provide useful meta-information about library,
in addition to providing the usual #require and #load to load the
files belonging to the library.</p>

<p>The system consists of three main scripts, <code>library.rb</code>,
<code>package.rb</code> and <code>version.rb</code> and a
few of simple conventions for taking advantage of Roll's benefits.</p>

<p>That's a very techincal view of Rolls. For the end-user/end-prgrammer
Rolls makes life easier because it laregly nullifies the installation
process. If you are working on a project, for instance, and changes
will be live. There is no need to go throught an re-install process.
If you are installing a Ruby package Rolls makes it as easy as unpacking
a copy of a repository into the standard location.</p>

<p>A releated question, is what isn't Rolls? Rolls is not a <i>package manager</i>.
Unlike RubyGems, Rolls simply manages libraries. It does not care how they got
to the system. As long as Rolls knows were to look, and the package conforms to
some simple conventions, then Rolls will serve the files up.</p>

<h2 id="ch_feature"> Feature Highlights </h2>

  <ul>
  <li>Object-oriented library interface</li>
  <li>Promotion of good standard conventions</li>
  <li>Flexible support for versioning</li>
  <li>Ensure against file name clashes</li>
  <li>Greater project organization independence</li>
  <!--
  <li>Safely allows relative, instead of absolute, requiring</li>
  <li>Supports "private" library sub-directories</li>
   -->
  <li>Not tied to a particular package/distribution system</li>
  </ul>

<h2 id="ch_install">How to Install</h2>

<p>Installation is straight-forward. Download the package file,
decompress it, 'cd' into the uncompressed directory and run
<code>task/setup</code>.</p>

<pre>
  % wget http://rubyforge.org/frs/download.php/11057/roll-x.y.z.tar.gz
  % tar -xvvjf roll-x.y.z
  % cd roll-x.y.z
  % sudo task/setup <i>(</i>ruby task/setup <i>for Windows users)</i>
</pre>

<p>Once Roll is intalled you can start using it by adding <code>-roll</code> to your
<code>RUBYOPT</code> environment variable.</p>

<pre>
  % export RUBYOPT="-roll"
</pre>

<p>You may want to add this to the master profile or to your own
.bashrc file so it starts automatically in the future.</p>

<p>Lastly, to get bin/ support, you will need add a small script to .bashrc or
the equivalent to your particular shell start-up code. Here is an example
of a possible setup.</p>

<pre>
  # At the end of ~/.bashrc

  if [ -f ~/.rubyrc ]; then
    . ~/.rubyrc
  fi
</pre>

<pre>
  # cat ~/.rubyrc
  export RUBYFORGE_USERNAME="yourname"
  export RUBYOPT="-roll -rubygems"
  export ROLL_PATH="/path/to/your/ruby/repos"
  export PATH="$PATH:$(roll --path)"
</pre>

<p>Notice in our example, ROLL_PATH. This points to the location of the Ruby projects
your working on.</p>

<p class="important">NOTE: Roll does not yet support executables on Windows.
It's being worked on, but library support should work fine.</p>


<h2>Status</h2>

<p>Rolls has actually gone through a number of re-writes to test various possible
implementations and refine it's functionality. At this point it is fairly stable,
though some parts of the API may yet change and a few consideration's still need
to be finalized, such as Windows exe support and the efficiency of scanning process.
We don't recommend using it in producation environments quite yet, but it is
certainly more than aequate and useful in developement environments.</p>


<h2 id="ch_who"> Who Developed This? </h2>

<p>The roll.rb script was written by Trans with support from Peter Vanbroekhoven.</p>


<!-- USING -->

<h1 id="ch_user"> Rolling for End User </h1>

<h2 id="ch_quick"> The Quick Rollout </h2>

<p>Using a rolled Ruby library isn't much different than using a non-rolled
one. For instance the demo app incuded in the Rolls distribution can
be tested (after installing it) from irb just by typing:</p>

<pre>
    require 'fruitapp:tryme'
</pre>

<p>The roll system will see that 'fruitapp' is a "rolled" library and automatically
instantiate it, selecting the most recent version, then proceed to require <code>tryme.rb</code>.</p>

<p>For backward compatability, it is also possible to do:</p>

<pre>
    require 'fruitapp/tryme'
</pre>

<p>In this case though, Rolls will first try to load the file using Ruby's normal require mechinsim, failing that
Rolls has to figure out that <code>fruitapp</code> is a rolled library. While fairly marginal, this does increae
load times. Efficiency increases approx. 2-3 times by explicitly telling Rolls that <code>fruitapp</code>
is a rolled library using the ':'. Howerver, the trade-off is that your library/applcation will require the
the use Rolls to function. Through-out this overview we will usually use the ':' to keep things clear. <i>Just
remember that you can use '/' in it's place</i>.</p>

<p>Rather then have Rolls automatically select the latest verison of a library you can manually <i>activate</i>
a specific version via a version constraint. This is most easily achieved with the provided
<code>#library</code> Kernel method.</p>

<pre>
    library 'fruitapp', '= 1.0'
    require 'fruitapp:tryme'
</pre>

<p>So in this example, specifically version 1.0 of fruitapp will be used.
The <code>#library</code> method does more than simply select a version.
In fact, the verison parameter is optional --when no version constraint is given
the most recent available version is selected. The <code>#library</code> method
also returns returns a <i>Library</i> object.</p>

<p>Ah, but now we're starting to go beyond the "Quick" of things.
That's pretty much all you <i>have</i> to know to use a rolled library.</p>


<h2 id="ch_class"> The Library Class </h2>

<p>When you use the Kernel method, <code>#library</code>, you're actually just using a shortcut for
instantiating a new Library object. You can do the same thing using <code>Library.instance</code>
or <code>Library.open</code> methods.</p>

<pre>
    Library.instance('fruitapp')   #=> #&lt;Library fruitapp/1.0.1&gt;
    Library.open('fruitapp')       #=> #&lt;Library fruitapp/1.0.1&gt;
</pre>

<p>The <code>#instance</code> and <code>#open</code> methods require the library name as the
first parameter <!-- , which is also the name of the library's directory within the file system.-->.
The name is then used as the ledger key to track the library. The difference between
<code>#instance</code> and <code>#open</code> is that <code>#open</code>
will raise an error if the library is not found and can also take a block which yields on the
library. In addition, there is a shorter alias for <code>#instance</code> provided as <code>#[]</code>.
Like <code>#instance</code>, it too will not raise an error if the the library is not found,
but will simply return <code>nil</code>.</p>

<pre>
    Library['fruitapp']  #=> #&lt;Library fruitapp/1.0.1&gt;
    Library['notthere']  #=> nil
</pre>

<p>Library is <i>multiton</i>, which means only one instance exists per name.
Calling <code>#library</code>, <code>Library.instance</code>, <code>Library.open</code> or
<code>Library.[]</code> repeatedly using the same name will return the very same
Library object.</p>

<p>When selecting a version, the constraint is a simple string starting with an
operator, like <code>=</code> or <code>&gt;=</code>, followed by the string
representaion of a version number. For instance,</p>

<pre>
    Library.instance('fruitapp', '~> 1.0')     #=> #&lt;Library fruitapp/0.9&gt;
    Library.instance('fruitapp', '== 2.0')     #=> #&lt;Library fruitapp/2.0&gt;
</pre>

<p>Once a version is selected the version can not be changed.
A Library::VersionConflict will be raised if one attempts to do so.</p>

<p><i>NOTE: This restriction has put in place to prevent conflicts which
can arise when libraries extend core functionality. Certainly it would be
nice if multiple-versions could work harmoniously, but this not even 
remotely possible until such time as Ruby supports selector namespaces.
In the future though we may be able to reduce the restrinction to just
the use of #require and #load.</i></p>

<!-- However, Roll will not raise and error should
you have special need to do exactly that (although it may raise a warning).
Once selected, the Library class will delegate calls to the current
version. If you attempt to use a library without first selecting a
version, the latest version will be atomically selected.-->

<p>Now, with a library in hand, the most useful method provided is #require.</p>

<pre>
    library('fruitapp').require 'tryme'
</pre>

<p>As you can see this is pure OOP. You could store the reference to
the library for later access, even pass it around as an argument.</p>

<pre>
    fruitlib = Library.open('fruitapp', '=1.0')
    fruitlib.require 'tryme'
</pre>


<h2 id="ch_other"> Related Locations </h2>

<p><b><i>NOTE: This section is not wholey correct.</i></b></p>

<p>To facilitate access to file locations pertaining to
a library, Rolls provides some convenient methods.
Normally this information is accessed by using rbconfig.rb and
building a path based on information in the Config::CONFIG hash.
For instance, <code>Config:CONFIG['datadir']</code>
on a Debian system points to /usr/share. With Roll you can look up
the data dir specific to the current library via the <code>#datadir</code> 
method, and likewise for the other directories. Here's a example rundown
with resolutions for a Debian system.</p>

<!--
<pre>
  # library directory
  library('fruitapp').libdir           #=> [ "/usr/local/lib/site_ruby/1.8/fruitapp/1.0.0/" ]
-->

<pre>
  # configuration dir
  library('fruitapp').confdir          #=> "/etc/fruitapp/"

  # versioned data dir
  library('fruitapp').datadir          #=> "/usr/share/fruitapp/1.0.0/"

  # ensure non-versioned data dir
  library('fruitapp').datadir(true)    #=> "/usr/share/fruitapp/"
</pre>

<p>Another way to access these locations is via Ruby's own Config module. Eg.
Config.datadir('fruitapp'). This provides a wholly general interface
to this information, irregardless of the system providing it, whether it be
Rolls, Gems or some other system.</p>

<p>With Rolls, a project's <code>bin/</code> directory is not versioned, unlike
the <code>lib/</code> directory. It doesn need to be because a simple
convention makes it possible to version executable files: In so far as an executable
is to be versioned (and it's generally a good idea to do so) one should wrap the logic
in a file under the versioned <code>lib/</code> directry, then simply requiring or
load the lib file into the executable file. It's a simple enough practice and doing
it in this manner means that no specialized action is required of any packaging
or distribution system. Here is a good example of such a file.</p>

<pre>
    #!/usr/bin/env ruby
    version = "> 0"
    if ARGV.size > 0 && ARGV[0][0]==95 && ARGV[0][-1]==95
      if Library::Version.correct?(ARGV[0][1..-2])
        version = ARGV[0][1..-2]
        ARGV.shift
      end
    end
    library 'camping', version
    load 'camping'
</pre>

<h2 id="ch_meta"> Library Metadata </h2>

<p>Additional meta-information may also be provided via a library's
specification file which is accessible via the <code>Library</code>
interface. This is optional information that may or may not be
provided by the project developers.</p>

<p>To tell if any meta-information has been provided, query the 
library with the <code>#metainfo?</code> call. If so then other
information can be queried. For instance:</p>

<pre>
  library('fruitapp').title        #=> "Fruit Basket Application"
  library('fruitapp').description  #=> "Example application to demonstrate roll.rb."
  library('fruitapp').author       #=> "Trans"
</pre>

<p>Additional fields will be added in the future as prove suitable.</p>



<!-- DEVELOPING -->

<h1 id="ch_dev"> Rolling for Developers </h1>

<h2 id="ch_layout"> Versioned Layout </h2>

<p>Roll supports library versioning simply by working with you
typical repository layout, whether using Subversion, Darcs, Git or some
other versioning system, Rolls doesn't much care, as long as you
follow some basic conventions and provide a .roll metadata file.
The metadata file mean there is no need for special installation
repositories, procedures or supporting programs.</p>

<p>Your directory layout should generally follow the conventions set
by Minero Aoki's <code>setup.rb</code>. Roll simply adds a couple
additional details. Here's an example of a typical structured versioned
project repository layout.</p>

<!--
<p>To support versioning and to encourage clean divisions between projects,
Roll has taken a <i>inspiration</i> from the <b>taguri</b>
standard as a basis for library file and directory names.
You can learn more about taguri <a href="http://taguri.org">here</a>.<p>
The taguri standard is not suitable in itself to designate file and
directory names, but with some basic transformations and additions it is
admirably useful. Here is an example of what a projects taguri would be and
how that translates into a directory structure and a tar package file name.</p>

<pre>
  (1) tag:fruitbasket.rubyforge.org,2005-10-31:tryme.rb
  (2) fruitbasket.rubyforge.org/2005-10-31/tryme.rb
  (3) fruitbasket.rubyforge.org-2005.10.31.tgz (contains tryme.rb)
</pre>

<p>The first is the standard taguri. The second is how it is
represented in file system. And the third is, of course,
the directory packed in a tar file. While we would have liked the
packaged file name to more closely resemble the original taguri,
many source host services do not allow file names to have commas.
But also notice how the the date becomes a sub-directory of the uri.
This represents the version, and as such it need not be a date
--it could just as well be a series like '1.0.0'.</p>

<p>For clarity here's the above as it translates into a project's directory
layout.</p>
-->

<pre>
    fruitapp/
      tags/
        1.0.0/
          fruitapp-1.0.0.roll
          bin/
            ...
          lib/
            fruitapp/
              index.rb
              ...
      trunk/
        fruitapp-1.0.1.roll
        bin/
          ...
        lib/
          fruitapp/
            index.rb
            ...
</pre>

<p>Notice there is 1.0.0 tagged version, a 1.0.1 verison currently being worked on. The above layout
is your typcial subversoin repository. Another good layout structure, whether you use SUbversion or not is:</p>

<pre>
    fruitapp/
      1.0.0/
        fruitapp-1.0.0.roll
        bin/
          ...
        lib/
          fruitapp/
            index.rb
            ...
      current/
        fruitapp-1.0.1.roll
        bin/
          ...
        lib/
          fruitapp/
            index.rb
            ...
</pre>



<p>This demonstrates how Rolls can work with a variety of layouts. Rolls can also handle subprojects.
In fact Rolls can handle any layout up to three direcotory tiers below the ROLL_PATH location.</p>

<p>At this point you may be wondering how renaming the lib directory with a
changing version is even possible --how will the internal require statements
find their files? It's actually quite simple. When Rolls is required the
first thing it does is search the ROLL_PATH locations for .roll files and makes
a map of available libraries and their versions. Then when a library is
first referenced it is instatiated with a particluar version. From then on
requests against that libary are routed to that library object where the
correct path is used.</p>

<p>Rolls also works without versioning and the two can even be intrrmixed.
If two files with the same name exist in the versioned tier and the
non-versioed tier, the versioned file will take precedence.</p>

<!--
<h2 id="ch_local"> A Note or Two on Version Numbers </h2>

<p>Though the taguri standard suggests using a dating scheme to
differentiate library versions in the directory hierarchy, Roll
fully supports both date and dot-series versioning. How to utilize either
of these is a matter to be decided by the project's maintainer.
But we'll touch on them briefly to help understand the two useful methods.</p>

<p>Series-versioning is the most common form versioning in use today. If you take
a close look at the versions put out by a plethora of projects you will also
notice that it is more akin to an art-form than a science[<a href="#foot1">1</a>].
Nonetheless, if you follow a strict Rational Versioning Policy
of "major.minor.tiny" with regards to project changes, it can be helpful
in conveying <i>compatibility</i>, which can in turn provide the end-user
some means of insurance that their programs will remain functional even
after updates.</p>

<p>Date-versioning, OTOH, is not as common mainly because it is not
typically thought to have any semantic value beyond a release timestamp.
But by creatively utilizing the taguri standard, date-versioning can in
fact lend itself to greater version consistency with regard to release
<i>stability</i>. Just follow these four simple rules:
<pre>
  1) Unstable/development releases provide the day (YYYY-MM-DD)
  2) Official/stable releases remove the day (YYYY-MM)
  3) Ultrastable releases provide only the year (YYYY)
  4) For daily builds add a "build moment" by adding the time.
</pre>
With this Rational Versioning Policy, the intent is clear and meaningful and
has a natural way of forcing one to comply to the meaning, which is nice.
</p>
-->

<!--
<h2 id="ch_index"> The <code>index.rb</code> File </h2>

<p>You may be wondering what the </code>index.rb</code> file given in
the last exmaple. When a library is instantiated Rolls looks to see if
there is an index.rb file accosiated with it. If there is, it requires it.
index.rb is an optional file that can be used to automatically provide 
meta-information particular to the library and it's version, or to
automatically perform any setup that may be required upon instantiation
of the library.</p>

<p>The typical <code>index.rb</code> file will provided meta-information
about the library. The simplist way to provide this is via the
#index method.</p>

<pre>
    library('fruitapp').index do
      date  '2005-10-10'
      title 'Fruit Demo Applicaiton for Rolls'
    end
</pre>

<p>This is the same as the less convenient form.</p>

<pre>
    require 'roll/library.rb'
    library('fruitapp').date  '2005-10-10'
    library('fruitapp').title 'Fruit Demo Applicaiton for Rolls'
</pre>

<p>Or using <code>#open</code>.</p>

<pre>
    require 'roll/library.rb'
    library('fruitapp').open do |lib|
      lib.date  '2005-10-10'
      lib.title 'Fruit Demo Applicaiton for Rolls'
    end
</pre>

<p>The index file is loaded via #require just like any other file, so you can
run whatever code neccessary for the initialization of a library. In this
sense, the index.rb file is a library's version of a callback method.</p>
-->

<h2 id="ch_scope"> Load Scope </h2>

<p>One of the most important settings in the .roll file is the
the load scope, known as lib_path or load_path. By default the load scope
of a library is it's lib/ directory. But you can diversify
the load scope if you wish.

<p>Let us consider an example. Assume the following <code>lib/</code> layout:</p>

<pre>
    fruitapp/
      fruit/
        apple.rb
      basket/
        wicker.rb
</pre>

<p>By providing the library with a scope detailing which sub-directories
are to be accessible via the directory name, the internal directories are
automatically exposed to one another.


<pre>
  lib_path:
    - lib
    - lib/fruit
    - lib/basket
</pre>

<!--
<pre>
  library('fruitapp').scope( '.', 'fruit', 'basket' )
</pre>
-->

<p>So given the above, when requiring against the library, the system will search
all three internal paths instead of just the main lib/ path. The file
<code>apple.rb</code> can contain <code>require 'fruitapp/wicker.rb'</code>
and it will find the file in the <code>basket/</code> directory.</p>

<!--
<p>As mentioned in the features, Rolls provides internal library files access to
the library files around them without specifying absolute path names (i.e. relative
to the standard $LOAD_PATH). This is useful because it allows one the freedom
to reversion directories or rename subdirectories without needing to update every
require reference in one's scripts.</p>
-->


<!--
<p>is also made true by this. But lets say you do not wish for the
internal visibility to be the same as the outside visibility. Then
in addition to <code>main</code> provide a <code>scope</code> parameter.</p>

<pre>
  private:
    - foo
    - bar
</pre>

<p>In this example, internal files in the foo/ and bar/ directories will
be able to see each other, but they will not be able to see the library's
root directory (unless they specify the library's specific namespace, of course).
One can invert the coverage of the scope, having main contain less directories
and scope containing more. In this way the roll system provides semi-private
library directories.</p>

<p>Albeit rare, you should keep in mind that a conflict can arise if your
library contains a file within it's local scope that has the same name as
an external library or a built-in Ruby standard library file.
This will only effect a library trying to access both files.
When this occurs the local library file will take precedence. There are
two way to circumvent this. Firstly, you can specifically specify the 
library if it is another rolled library.</p>

<pre>
  library('alib').require 'afile.rb'
</pre>

Or you can use the specialized '::' marker to access standard ruby.</p>

<pre>
  require '::ostruct.rb'
</pre>

<span class="note">(NOTE <i>Presently <code>Library['ruby']</code> is NOT viable, but
it will be supported in the future.</i>)</span>
-->

<!--
Turning off ive dev?

<h2 id="ch_run"> Live Development </h2>

<p>Another nice feature of Rolls is the ability run an entire project completely
from the current working directory. If the $DEBUG flag is set (eg. ruby -d),
Rolls will ascend from current working directory searching for the a
<code>lib/</code> folder. If found the location is added to the $LOAD_SITES
list (like $LOAD_PATH but specific to Rolls). So it is easy to test
code directly from the development location, without any need to install.</p>
-->

<!-- CHOOSING -->

<h1 id="ch_choose"> It's How We Roll </h1>


<h2 id="ch_maint"> Benefits to Package Maintainers </h2>

<p>Because Rolls in package system agnostic, it is advantageous to the package maintainers
of operating systems. It is straight forward to repackage you libraries in their
favored packaging system.</p>

<!--
<h2 id="ch_gems"> Rolling past Gems </h2>

<p> This overview of Rolls makes no mention of the library it will inevitably be compared.
If you hadn't already realized, that library is RubyGems. No doubt Gems is great tool
and a lot of great work has been put into it. Rolls will work right along side Gems with out
complaint. Nonetheless Gems has some shortcomings which were the very motivation for the
creation of Rolls. Namely, that Gems is over reaching. Specifically, the fact that Gems
combines a package management system and a versioning system into an inseparable unit presents
unwarranted limitations. It would be understandable if there was no alternative, but
as Rolls demonstrates there is a very viable recourse.</p>


<h2 id="ch_concl"> Are You Ready to Roll? </h2>

<p>Do you want the advantages of Rolls? Given that Roll is light-weight,
robust and will work alongside Gems, thus allowing smooth transition,
adding a dependency to RubyRoll is a relatively easy choice.</p>
-->

<p>Whe you are ready to roll, we've created this spiffy graphic you can
use to let other know you offer a rolls compatible distribution.</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;<img src="img/ready.png"/></p>

</div>


<hr>

<div id="footnotes">
Footnotes:<br/>
[1] <a href="http://www.newsforge.com/article.pl?sid=05/06/08/136214&from=rss">Decline and fall of the version number</a>
</div>

<div id="copy">Copyright (c) 2005 Thomas Sawyer, all rights reserved.</div>

</html>
