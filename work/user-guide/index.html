<html>
<head>
  <title>Ready to Roll</title>
  <LINK REL="SHORTCUT ICON" HREF="../assets/images/ball/red_ball.jpg"/>
  <style>
             body { font-family: sans-serif; margin: 20px; color: #222222;
                    font-size: 11pt;}
               hr { margin: 0 auto; width: 710px; }
               li { font-size: 1em; }
             li a { color: #f66; font-weight: bold; }
                p { font-size: 1em; line-height: 1.2em; }
               h1 { margin-top: 50px; }
               h2 { margin-top: 40px; }
             code { color: blue; font-size: 0.9em; }
              pre { color: red; font-size: 0.9em; padding: 10px; }
          #header { margin: 0 auto; width: 700px; text-align: left; margin-bottom: 30px; }
       #container { margin: 0 auto; width: 700px; text-align: justify; margin-bottom: 30px; }
           #title { color: red; font-size: 96px;
                    letter-spacing: 10pt; font-weight: bold; }
        #subtitle { color: black; font-size: 10pt; padding-left: 0px; font-weight: bold; }
             #rev { background: red; color: white; }
       #footnotes { margin: 0 auto; width: 700px; font-size: 0.8em; }
            #copy { margin: 0 auto; width: 700px; font-size: 0.8em; margin-top: 10px; }
             .red { color: red; }
           .small { font-size: 10pt; }
           .note  { font-size: 1em; font-style: italic; }
  </style>

  <script type="text/javascript" src="http://tigerops.org/assets/systems/shjs/sh_main.js"></script>
  <script type="text/javascript" src="http://tigerops.org/assets/systems/shjs/lang/sh_ruby.js"></script>
  <script type="text/javascript" src="http://tigerops.org/assets/systems/shjs/lang/sh_sh.js"></script>
  <script type="text/javascript" src="http://tigerops.org/assets/systems/shjs/lang/sh_xml.js"></script>
  <script type="text/javascript" src="http://tigerops.org/assets/systems/shjs/lang/sh_html.js"></script>
  <link type="text/css" rel="stylesheet" href="http://tigerops.org/assets/systems/shjs/css/sh_berries-light.css">

</head>
<body onload="sh_highlightDocument();">

<div style="border: 2px solid red; margin: 0 auto; padding: 5px; margin-bottom: 20px; width: 800px;">
  <b>IMPORTANT NOTICE</b>
  THIS IS STILL A WORK IN PROGRESS. IT IS NOT COMPLETE AND DOES NOT NECESSARILY MATCH WITH THE CURRENT STATE OF DEVELOPMENT!!!
</div>

<div id="header">
  <div style="float:right;"><img src="../assets/images/ball/red_ball.jpg" height="200px"></div>
  <br/>
  <span id="title">Roll</span></br>
  <span id="subtitle">&nbsp;ruby object-oriented library ledger</span></br>
</div>

<div id="container">

<h1> Table of Contents </h1>

  <ol>
   <li> <a href="#ch_info">Introduction</a>
    <ol>
      <li><a href="#ch_about">   What is Roll(s)? </a></li>
      <!-- <li><a href="#ch_feature"> Feature Highlights        </a></li> -->
      <li><a href="#ch_install"> How to Install            </a></li>
      <li><a href="#ch_status">  Development Status        </a></li>
      <!-- <li><a href="#ch_who">     Who Developed This?       </a></li> -->

    </ol>
   </li>
   <li> <a href="#ch_cmd">The Roll Command</a>
    <ol>
      <li><a href="#ch_help">    Roll Command Help         </a></li>
      <li><a href="#ch_in">      Roll In and Out           </a></li>
      <li><a href="#ch_inst">    Roll Installs             </a></li>
    </ol>
   </li>
   <li> <a href="#ch_use">Using Rolled Libraries</a>
    <ol>
      <!-- <li><a href="#ch_libver">   Library Versioning     </a></li> -->
      <li><a href="#ch_layout">  Versioned Layout          </a></li>
      <li><a href="#ch_roll">    Metadata File             </a></li>
      <li><a href="#ch_scope">   Load Scope                </a></li>
      <!-- <li><a href="#ch_index">   The index.rb File         </a></li> -->
      <li><a href="#ch_run">     Live Development          </a></li>
      <li><a href="#ch_class">   The Library Class         </a></li>
      <li><a href="#ch_other">   Related Locations         </a></li>
      <li><a href="#ch_meta">    Library Metadata          </a></li>
    </ol>
   </li>
   <li> <a href="#ch_choose">It's How We Roll</a>
    <ol>
      <li><a href="#ch_maint">   Benefits to Developers    </a></li>
      <!-- <li><a href="#ch_gems">    Rolling past Gems     </a></li> -->
      <li><a href="#ch_concl">   Are You Ready to Roll?    </a></li>
    </ol>
   </li>
  </ol>

<h1 id="ch_info"> Introduction </h1>

<h2 id="ch_about"> What is Roll(s)? </h2>

<p><span class="red">Roll</span> (or <span class="red">Rolls</span>)
is a library manger. This is similiar to a package manager, but with
the key distinction that it circumvents any need for a <i>package</i>.
In other words, programs can be installed directly from their scm 
repositories.</p>

<p>This is especailly useful to Ruby developers. Rolls makes life easier
because it effectively nullifies any installation process. If you are
working on a project, just 'roll in' the working directory, and any 
changes will be live. There is no need to go through a re-install
process. This can also mitigate the need to handle dependent vendor
repositories per project.</p>

<p>Under the hood, <span class="red">Rolls</span> is an object-oriented
library ledgering system. In other words, a library, which is essentially
a location in a file system, can be instantiated as an object,
then used to provide useful meta-information about library,
in addition to providing the usual #require and #load to load the
files belonging to the library.</p>

<p>A releated question is, what isn't Rolls? Rolls is not a <i>package manager</i>.
Unlike RubyGems, Rolls simply manages libraries. It does not care how they got
to the system. As long as Rolls knows were to look, and the package conforms to
some simple conventions, then Rolls will serve the files up.</p>

<!--
<h2 id="ch_feature"> Feature Highlights </h2>

  <ul>
  <li>Object-oriented library interface</li>
  <li>Promotion of good standard conventions</li>
  <li>Flexible support for versioning</li>
  <li>Not tied to a particular package/distribution system</li>

  NOT CURRENTLY
  <li>Ensure against file name clashes</li>
  <li>Greater project organization independence</li>
  <li>Safely allows relative, instead of absolute, requiring</li>
  <li>Supports "private" library sub-directories</li>

  </ul>
-->

<h2 id="ch_install">How to Install Rolls</h2>

<p>Roll is best installed directly to your systems site-ruby location.
To do this you will need <a href="http://setup.rubyforge.org">Ruby Setup</a>.
With Ruby Setup, installation is straight-forward. Download the package file,
decompress it, 'cd' into the uncompressed directory and run
<code>sudo setup.rb</code>.</p>

<pre class="sh_sh">
  $ wget http://rubyforge.org/frs/download.php/11057/roll-x.y.z.tar.gz
  $ tar -xvzf roll-x.y.z
  $ cd roll-x.y.z
  $ sudo setup.rb
</pre>

<p>Once Rolls is intalled you can start using it by adding <code>-roll</code> to your
<code>RUBYOPT</code> environment variable.</p>

<pre class="sh_sh">
  $ export RUBYOPT="-roll"
</pre>

<p>You may want to add this to the master profile or to your own
.bashrc file so it starts automatically in the future.</p>

<p>Lastly, to get binary executable support, you will need add a small script
to .bashrc or the equivalent to your particular shell start-up code.
Here is an example of a possible setup.</p>

<pre class="sh_sh">
  # At the end of ~/.bashrc
  if [ -f ~/.rubyrc ]; then
    . ~/.rubyrc
  fi
</pre>

<pre class="sh_sh">
  # cat ~/.rubyrc
  export RUBYFORGE_USERNAME="yourname"
  export RUBYOPT="-roll -rubygems"
  export PATH="$PATH:$(roll path)"
</pre>

<p class="important">NOTE: Roll does not yet support executables on Windows.
It's being worked on, but library support should work fine.</p>


<h2 id="ch_status">Development Status</h2>

<p>Rolls has actually gone through a number of re-writes to test various possible
implementations and refine it's functionality. At this point it is fairly stable,
though some minor parts of the API may yet change. As a developer's tool it is
close to rock solid (I have been using for well over a year). The install command
is much more recent, however, and still needs testing and refinement.</p>

<!--
<h2 id="ch_who"> Who Developed This? </h2>

<p>Roll was written by Thomas Sawyer with support from Peter Vanbroekhoven.</p>
-->


<!-- COMMAND -->

<h1 id="ch_cmd">The Roll Command</h1>

<h2 id="ch_help">The Roll Command Help</h2>

<p>Rolls provides a command line tool called, obvious enough, <code>roll</code>.</p>

<pre class="sh_sh">
  $ roll --help
  usage: roll <command> [options] [arguments]

  commands:
    in/insert   insert current project into ledger
    out/remove  remove current project from ledger
    ledger      list the ledger entries
    clean       clean ledger of invalid entries
    path        output ledger bin PATH
    install     install a project
    uninstall   uninstall a project
    update      update a project
    versions    list project versions
    help        provide help information
</pre>

<p>You can use help to get more information on each of these commands.</p>

<h2 id="ch_in">Roll In and Out</h2>

<p>As a developer the first handful of commands will be of most use.
For instance, lets say you are working on a project that uses
<a href="http://facets.rubyforge.org">Ruby Facets</a> and you want to have
the project close at hand. So you have cloned the git repository.

<pre class="sh_sh">
  $ git clone git://rubyforge.org/facets.git facets
</pre>

<p>All you need to do to bring it online is to cd into project,
ensure it has a VERSION file and the roll the library in. Facets
has a VERSION file so all you'd need to do is:</p>

<pre class="sh_sh">
  $ cd facets
  $ roll in
</pre>

<p>This will add the current project's location to your library ledger
(stored in <code>~/$XDG_CONFIG_HOME/roll/ledger.list</code>).</p>

<p>The only caveat to this is that you need to make sure the project has
a VERSION file in the format of (using Facets as an example):</p>

<pre class="sh_sh">
  $ cat VERSION
  facets 2.5.1 stable (2008-11-30)
</pre>

<p>If it does not, simply create one. You don't need to check it into the
repository.</p>


<h2 id="ch_inst">Roll Installs</h2>

<p>As a general user, Rolls can be used to install software in such a way
as to alleviate the project maintatiner from the chore of creating special
install packages.</p>

<pre class="sh_sh">
  $ roll install foo
</pre>

<p>By default, projects are looked for at rubyforge.org. One can specify that
they are looked for at github instead with the '-g' option.</p>

<p>If no version is given, the latest tagged version will be installed.
You can install a specific version using the <code>--version</code> option.</p>


<!-- USING -->

<h1 id="ch_use"> Using Rolled Libraries </h1>

<h2 id="ch_quick"> Require and Load </h2>

<p>Using a rolled Ruby library isn't much different than using a non-rolled
one. For instance the demo app incuded in the Rolls distribution can
be tested (after rolling it in) from irb just by typing:</p>

<pre class="sh_ruby">
    require 'fruitapp:tryme'
</pre>

<p>The roll system will see that 'fruitapp' is a rolled library and automatically
instantiate it, selecting the most recent version, then proceed to require <code>tryme.rb</code>.</p>

<p>For backward compatability, it is also possible to do:</p>

<pre class="sh_ruby">
    require 'fruitapp/tryme'
</pre>

<p>In this case though, Rolls will first try to load the file using Ruby's normal require mechinsim, failing that
Rolls has to figure out that <code>fruitapp</code> is a rolled library. While fairly marginal, this does increae
load times. Efficiency increases approx. 2-3 times by explicitly telling Rolls that <code>fruitapp</code>
is a rolled library using the ':'. However, the trade-off is that your library/applcation will require the
the use Rolls to function. Through-out this guide we will usually use the ':' to keep things clear. <i>Just
remember that you can use '/' in it's place</i>.</p>

<p>Rather then have Rolls automatically select the latest verison of a library you can manually <i>activate</i>
a specific version via a version constraint. This is most easily achieved with the provided
<code>#library</code> Kernel method.</p>

<pre class="sh_ruby">
    library 'fruitapp', '= 1.0'
    require 'fruitapp:tryme'
</pre>

<p>So in this example, specifically version 1.0 of fruitapp will be used.
The <code>#library</code> method does more than simply select a version.
In fact, the verison parameter is optional --when no version constraint is given
the most recent available version is selected. The <code>#library</code> method
also returns returns a <i>Library</i> object.</p>


<h2 id="ch_class"> The Library Class </h2>

<p>When you use the Kernel method, <code>#library</code>, you're actually just using a shortcut for
instantiating a new Library object. You can do the same thing using <code>Library.instance</code>
or <code>Library.open</code> methods.</p>

<pre class="sh_ruby">
    Library.instance('fruitapp')   #=> #&lt;Library fruitapp/1.0.1&gt;
    Library.open('fruitapp')       #=> #&lt;Library fruitapp/1.0.1&gt;
</pre>

<p>The <code>#instance</code> and <code>#open</code> methods require the library name as the
first parameter <!-- , which is also the name of the library's directory within the file system.-->.
The name is then used as the ledger key to track the library. The difference between
<code>#instance</code> and <code>#open</code> is that <code>#open</code>
will raise an error if the library is not found and can also take a block which yields on the
library. In addition, there is a shorter alias for <code>#instance</code> provided as <code>#[]</code>.
Like <code>#instance</code>, it too will not raise an error if the the library is not found,
but will simply return <code>nil</code>.</p>

<pre class="sh_ruby">
    Library['fruitapp']  #=> #&lt;Library fruitapp/1.0.1&gt;
    Library['notthere']  #=> nil
</pre>

<p>Library is <i>multiton</i>, which means only one instance exists per name.
Calling <code>#library</code>, <code>Library.instance</code>, <code>Library.open</code> or
<code>Library.[]</code> repeatedly using the same name will return the very same
Library object.</p>

<p>When selecting a version, the constraint is a simple string starting with an
operator, like <code>=</code> or <code>&gt;=</code>, followed by the string
representaion of a version number. For instance,</p>

<pre class="sh_ruby">
    Library.instance('fruitapp', '~> 1.0')     #=> #&lt;Library fruitapp/0.9&gt;
    Library.instance('fruitapp', '== 2.0')     #=> #&lt;Library fruitapp/2.0&gt;
</pre>

<p>Once a version is selected the version can not be changed.
A Library::VersionConflict will be raised if one attempts to do so.</p>

<p><i>NOTE: This restriction has put in place to prevent conflicts which
can arise when libraries extend core functionality. Certainly it would be
nice if multiple-versions could work harmoniously, but this not even 
remotely possible until such time as Ruby supports selector namespaces.
In the future though we may be able to reduce the restrinction to just
the use of #require and #load.</i></p>

<!-- However, Roll will not raise and error should
you have special need to do exactly that (although it may raise a warning).
Once selected, the Library class will delegate calls to the current
version. If you attempt to use a library without first selecting a
version, the latest version will be atomically selected.-->

<p>Now, with a library in hand, the most useful method provided is #require.</p>

<pre class="sh_ruby">
    library('fruitapp').require 'tryme'
</pre>

<p>As you can see this is pure OOP. You could store the reference to
the library for later access, even pass it around as an argument.</p>

<pre>
    fruitlib = Library.open('fruitapp', '=1.0')
    fruitlib.require 'tryme'
</pre>


<h2 id="ch_other"> Related Locations </h2>

<p><b><i>NOTE: This section is not wholey correct.</i></b></p>

<p>To facilitate access to file locations pertaining to
a library, Rolls provides some convenient methods.
Normally this information is accessed by using rbconfig.rb and
building a path based on information in the Config::CONFIG hash.
For instance, <code>Config:CONFIG['datadir']</code>
on a Debian system points to /usr/share. With Roll you can look up
the data dir specific to the current library via the <code>#datadir</code> 
method, and likewise for the other directories. Here's a example rundown
with resolutions for a Debian system.</p>

<!--
<pre>
  # library directory
  library('fruitapp').libdir           #=> [ "/usr/local/lib/site_ruby/1.8/fruitapp/1.0.0/" ]
-->

<pre class="sh_ruby">
  # configuration dir
  library('fruitapp').confdir          #=> "/etc/fruitapp/"

  # versioned data dir
  library('fruitapp').datadir          #=> "/usr/share/fruitapp/1.0.0/"

  # ensure non-versioned data dir
  library('fruitapp').datadir(true)    #=> "/usr/share/fruitapp/"
</pre>

<p>Another way to access these locations is via Ruby's own Config module. Eg.
Config.datadir('fruitapp'). This provides a wholly general interface
to this information, irregardless of the system providing it, whether it be
Rolls, Gems or some other system.</p>

<p>With Rolls, a project's <code>bin/</code> directory is not versioned, unlike
the <code>lib/</code> directory. It doesn need to be because a simple
convention makes it possible to version executable files: In so far as an executable
is to be versioned (and it's generally a good idea to do so) one should wrap the logic
in a file under the versioned <code>lib/</code> directry, then simply requiring or
load the lib file into the executable file. It's a simple enough practice and doing
it in this manner means that no specialized action is required of any packaging
or distribution system. Here is a good example of such a file.</p>

<pre class="sh_ruby">
    #!/usr/bin/env ruby
    version = "> 0"
    if ARGV.size > 0 && ARGV[0][0]==95 && ARGV[0][-1]==95
      if Library::Version.correct?(ARGV[0][1..-2])
        version = ARGV[0][1..-2]
        ARGV.shift
      end
    end
    library 'camping', version
    load 'camping'
</pre>

<h2 id="ch_meta"> Library Metadata </h2>

<p>Additional meta-information may also be accessed via the
<code>Library</code> interface. This is optional information
that may or may not be provided by the project developers.</p>

<p>To tell if any metadata has been provided, query the 
library with the <code>#metadata?</code> call. If true, then
other information will be availabe. For instance:</p>

<pre class="sh_ruby">
  library('fruitapp').title     #=> "Fruit Basket Application"
  library('fruitapp').summary   #=> "Example application to demonstrate roll.rb."
  library('fruitapp').author    #=> "Trans"
</pre>

<p>The field names are arbitrary and are dervied from individual files of
a project's <code>meta/</code> directory, or from a <code>META.yml</code> file.</p>


<h2 id="ch_layout"> Versioned Layout </h2>

<p>Roll supports library versioning simply by working with the
typical repository layout, whether using Subversion, Darcs, Git or some
other versioning system, Rolls doesn't much care, as long as you
follow some basic conventions and provide the necessary metadata.
The metadata file means there is no need for special installation
repositories, procedures or supporting programs.</p>

<p>Your directory layout should generally follow the conventions set
by Minero Aoki's <code>setup.rb</code>. Roll simply adds a couple
additional details.</p> 

<p>Here's an example of a typical Subversion project layout.</p>

<pre class="sh_sh">
    fruitapp/
      tags/
        1.0.0/
          VERSION
          bin/
            ...
          lib/
            fruitapp/
              index.rb
              ...
      trunk/
        VERSION
        bin/
          ...
        lib/
          fruitapp/
            index.rb
            ...
</pre>

<p>Notice there is 1.0.0 tagged version and a new verison currently being worked on. The above layout
is your typcial subversoin repository. Another viable layout is:</p>

<pre class="sh_sh">
    fruitapp/
      1.0.0/
        VERSION
        bin/
          ...
        lib/
          fruitapp/
            index.rb
            ...
      current/
        VERSION
        bin/
          ...
        lib/
          fruitapp/
            index.rb
            ...
</pre>

<p>This demonstrates the two varieties of Subversion layout that Rolls can comprehend.
Other SCM's that use directories for tagging with have the same layout. Git, and any
SCM that tracks tags internally, on the other hand, will of course not have these
additonal layer of subdirectories.</p>

<p>At this point you may be wondering how renaming the lib directory with a
changing version is even possible --how will the internal require statements
find their files? It's actually quite simple. Rolls keeps a map of available
libraries and their versions. When a library is first referenced it is
instatiated with a particluar version. From then on requests against that
libary are routed to that library object where the correct path is used.</p>

<p><img src="../assets/images/important.png" align="left" style="margin-right: 10px;">
It important to keep the VERSION file up to date. The version number in the 
VERSION file must correspond to the tag name for <code>roll install</code> to
work correctly. This is becuase the install command uses the tag name to 
locate versions, but Roll's <code>require</code> method uses the VERSION file.</p>

<!--
<h2 id="ch_index"> The <code>index.rb</code> File </h2>

<p>You may be wondering what the </code>index.rb</code> file given in
the last exmaple. When a library is instantiated Rolls looks to see if
there is an index.rb file accosiated with it. If there is, it requires it.
index.rb is an optional file that can be used to automatically provide 
meta-information particular to the library and it's version, or to
automatically perform any setup that may be required upon instantiation
of the library.</p>

<p>The typical <code>index.rb</code> file will provided meta-information
about the library. The simplist way to provide this is via the
#index method.</p>

<pre>
    library('fruitapp').index do
      date  '2005-10-10'
      title 'Fruit Demo Applicaiton for Rolls'
    end
</pre>

<p>This is the same as the less convenient form.</p>

<pre>
    require 'roll/library.rb'
    library('fruitapp').date  '2005-10-10'
    library('fruitapp').title 'Fruit Demo Applicaiton for Rolls'
</pre>

<p>Or using <code>#open</code>.</p>

<pre>
    require 'roll/library.rb'
    library('fruitapp').open do |lib|
      lib.date  '2005-10-10'
      lib.title 'Fruit Demo Applicaiton for Rolls'
    end
</pre>

<p>The index file is loaded via #require just like any other file, so you can
run whatever code neccessary for the initialization of a library. In this
sense, the index.rb file is a library's version of a callback method.</p>
-->

<h2 id="ch_scope"> Load Path </h2>

<p>One of the most important settings in the .roll file is the the load path,
By default the load scope of a library is it's lib/ directory. But you can 
vary the load path if need be.

<p>Let us consider an example. Assume the following <code>lib/</code> layout:</p>

<pre class="sh_sh">
    fruitapp/
      fruit/
        apple.rb
      basket/
        wicker.rb
</pre>

<p>By providing the library with a scope detailing which sub-directories
are to be accessible via the directory name, the internal directories are
automatically exposed to one another.

<pre class="sh_ruby">
  loadpath:
    - lib
    - lib/fruit
    - lib/basket
</pre>

<!--
<pre>
  library('fruitapp').scope( '.', 'fruit', 'basket' )
</pre>
-->

<p>So given the above, when requiring against the library, the system will search
all three internal paths instead of just the main lib/ path. The file
<code>apple.rb</code> can contain <code>require 'fruitapp/wicker.rb'</code>
and it will find the file in the <code>basket/</code> directory.</p>


<!--
<h2>Relative Loading</h2>

<p>As mentioned in the features, Rolls provides internal library files access to
the library files around them without specifying absolute path names (i.e. relative
to the standard $LOAD_PATH). This is useful because it allows one the freedom
to reversion directories or rename subdirectories without needing to update every
require reference in one's scripts.</p>

<p>Albeit rare, you should keep in mind that a conflict can arise if your
library contains a file within it's local scope that has the same name as
an external library or a built-in Ruby standard library file.
This will only effect a library trying to access both files.
When this occurs the local library file will take precedence. There are
two way to circumvent this. Firstly, you can specifically specify the 
library if it is another rolled library.</p>

<pre>
  library('alib').require 'afile.rb'
</pre>

Or you can use the specialized '::' marker to access standard ruby.</p>

<pre>
  require '::ostruct.rb'
</pre>

<span class="note">(NOTE <i>Presently <code>Library['ruby']</code> is NOT viable, but
it will be supported in the future.</i>)</span>
-->


<!-- CHOOSING -->

<h1 id="ch_choose"> It's How We Roll </h1>


<h2 id="ch_maint"> Benefits to Developers </h2>

<p>Because Rolls in package agnostic, it largely removes the burden of
distribution.</p>

<!--
<h2 id="ch_gems"> Rolling past Gems </h2>

<p> This overview of Rolls makes no mention of the library it will inevitably be compared.
If you hadn't already realized, that library is RubyGems. No doubt Gems is great tool
and a lot of great work has been put into it. Rolls will work right along side Gems with out
complaint. Nonetheless Gems has some shortcomings which were the very motivation for the
creation of Rolls. Namely, that Gems is over reaching. Specifically, the fact that Gems
combines a package management system and a versioning system into an inseparable unit presents
unwarranted limitations. It would be understandable if there was no alternative, but
as Rolls demonstrates there is a very viable recourse.</p>
-->

<h2 id="ch_concl"> Are You Ready to Roll? </h2>

<!--
<p>Do you want the advantages of Rolls? Given that Roll is light-weight,
robust and will work alongside Gems, thus allowing smooth transition,
adding a dependency to RubyRoll is a relatively easy choice.</p>
-->

<p>When you are ready to roll, we've created this spiffy graphic you can
use to let other know you offer a rolls compatible distribution.</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;<img src="../assets/images/ready.png"/></p>

</div>


<hr>

<!--
<div id="footnotes">
Footnotes:<br/>
[1] <a href="http://www.newsforge.com/article.pl?sid=05/06/08/136214&from=rss">Decline and fall of the version number</a>
</div>
-->

<div id="copy">Copyright (c) 2005,2008 TigerOps & Thomas Sawyer, all rights reserved.</div>

</html>



<!--
<p>To support versioning and to encourage clean divisions between projects,
Roll has taken a <i>inspiration</i> from the <b>taguri</b>
standard as a basis for library file and directory names.
You can learn more about taguri <a href="http://taguri.org">here</a>.<p>
The taguri standard is not suitable in itself to designate file and
directory names, but with some basic transformations and additions it is
admirably useful. Here is an example of what a projects taguri would be and
how that translates into a directory structure and a tar package file name.</p>

<pre>
  (1) tag:fruitbasket.rubyforge.org,2005-10-31:tryme.rb
  (2) fruitbasket.rubyforge.org/2005-10-31/tryme.rb
  (3) fruitbasket.rubyforge.org-2005.10.31.tgz (contains tryme.rb)
</pre>

<p>The first is the standard taguri. The second is how it is
represented in file system. And the third is, of course,
the directory packed in a tar file. While we would have liked the
packaged file name to more closely resemble the original taguri,
many source host services do not allow file names to have commas.
But also notice how the the date becomes a sub-directory of the uri.
This represents the version, and as such it need not be a date
--it could just as well be a series like '1.0.0'.</p>

<p>For clarity here's the above as it translates into a project's directory
layout.</p>
-->

<!--
<h2 id="ch_local"> A Note or Two on Version Numbers </h2>

<p>Though the taguri standard suggests using a dating scheme to
differentiate library versions in the directory hierarchy, Roll
fully supports both date and dot-series versioning. How to utilize either
of these is a matter to be decided by the project's maintainer.
But we'll touch on them briefly to help understand the two useful methods.</p>

<p>Series-versioning is the most common form versioning in use today. If you take
a close look at the versions put out by a plethora of projects you will also
notice that it is more akin to an art-form than a science[<a href="#foot1">1</a>].
Nonetheless, if you follow a strict Rational Versioning Policy
of "major.minor.tiny" with regards to project changes, it can be helpful
in conveying <i>compatibility</i>, which can in turn provide the end-user
some means of insurance that their programs will remain functional even
after updates.</p>

<p>Date-versioning, OTOH, is not as common mainly because it is not
typically thought to have any semantic value beyond a release timestamp.
But by creatively utilizing the taguri standard, date-versioning can in
fact lend itself to greater version consistency with regard to release
<i>stability</i>. Just follow these four simple rules:
<pre>
  1) Unstable/development releases provide the day (YYYY-MM-DD)
  2) Official/stable releases remove the day (YYYY-MM)
  3) Ultrastable releases provide only the year (YYYY)
  4) For daily builds add a "build moment" by adding the time.
</pre>
With this Rational Versioning Policy, the intent is clear and meaningful and
has a natural way of forcing one to comply to the meaning, which is nice.
</p>
-->


<!--
<p>is also made true by this. But lets say you do not wish for the
internal visibility to be the same as the outside visibility. Then
in addition to <code>main</code> provide a <code>scope</code> parameter.</p>

<pre>
  private:
    - foo
    - bar
</pre>

<p>In this example, internal files in the foo/ and bar/ directories will
be able to see each other, but they will not be able to see the library's
root directory (unless they specify the library's specific namespace, of course).
One can invert the coverage of the scope, having main contain less directories
and scope containing more. In this way the roll system provides semi-private
library directories.</p>
-->

<!--
Turning off live dev?

<h2 id="ch_run"> Live Development </h2>

<p>Another nice feature of Rolls is the ability run an entire project completely
from the current working directory. If the $DEBUG flag is set (eg. ruby -d),
Rolls will ascend from current working directory searching for the a
<code>lib/</code> folder. If found the location is added to the $LOAD_SITES
list (like $LOAD_PATH but specific to Rolls). So it is easy to test
code directly from the development location, without any need to install.</p>
-->

